from dataclasses import dataclass, field
from typing import List

@dataclass
class Line:
    """Represents a single line within a code block."""
    line_number: int
    content: str


@dataclass
class MatchedLine(Line):
    def __init__(self, line_number: int, content: str, is_match: bool):
        super().__init__(line_number=line_number, content=content)
        self.is_match = is_match
        

@dataclass
class CodeBlock:
    """Represents a contiguous block of code which can contain matched lines.
    
    This abstraction is used to represent a code block that can be matched by the rg command or a block of code that is generated by an LLM.
    """
    filepath: str
    start_line: int # First line number in the block (including context)
    lines: List[Line] = field(default_factory=list) # List of lines in the block
    _original_file_content: str = field(default=None, init=False)

    @property
    def end_line(self) -> int:
        """Returns the last line number in the block (including context)."""
        return self.start_line + len(self.lines) - 1
    
    @property
    def code_block_with_line_numbers(self) -> str:
        """Returns the full code block as a single string with line numbers."""
        return "\n".join(f"{line.line_number}: {line.content}" for line in self.lines)
    
    @property
    def code_block_without_line_numbers(self) -> str:
        """Returns the full code block as a single string without line numbers."""
        return "\n".join(line.content for line in self.lines)

    @property
    def matched_lines_numbers(self) -> List[int]:
        """Returns line numbers that directly matched the pattern."""
        return [line.line_number for line in self.lines if line.is_match]
    
    @property
    def original_file_content(self) -> str:
        """Returns the full original file content as a single string."""
        if self._original_file_content is None:
            with open(self.filepath, 'r') as file:
                self._original_file_content = file.read()
        return self._original_file_content
    
    @property
    def len_lines(self) -> int:
        """Returns the number of lines in the code block."""
        return len(self.lines)

class EditCodeBlock(CodeBlock):
    """Represents a code block that represent a code that has been edited by an LLM.
    
    It has an original end line, which is the last line of the original code block.
    Its start line in the file is the same as the first line of the original code block.
    """

    def __init__(self, lines: List[Line], original_block: CodeBlock):
        super().__init__(filepath=original_block.filepath, start_line=original_block.start_line, lines=lines)
        self.original_block = original_block

    @property
    def original_end_line(self) -> int:
        """Returns the last line number in the original code block."""
        return self.original_block.end_line

    @property
    def len_lines_of_original_block(self) -> int:
        """Returns the number of lines in the original code block."""
        return self.original_block.len_lines


def CreateEditCodeBlockFromCodeString(editted_code_string: str, original_block: CodeBlock=None) -> EditCodeBlock:
    """Creates an EditCodeBlock from a code string."""
    lines = [Line(line_number=i+1, content=line + "\n") for i, line in enumerate(editted_code_string.split("\n"))]
    return EditCodeBlock(lines=lines, original_block=original_block)


@dataclass
class CodeMatchedResult:
    """Encapsulates the results of an rg search."""
    total_files_matched: int = 0
    total_lines_matched: int = 0 # Number of lines *directly* matching the pattern
    matches: List[CodeBlock] = field(default_factory=list) # List of matched code blocks
    rg_stats_raw: str = "" # Raw statistics output from rg --stats
    rg_command_used: str = "" # The full rg command executed


def edit_file_with_edited_blocks(filepath: str, edit_blocks: List[EditCodeBlock]):
    """
    Takes a list of edit CodeBlocks and edits the file they represent.
    
    Args:
        filepath: The path to the file to edit
        edit_blocks: List of CodeBlock objects containing the edits to apply
        
    Raises:
        ValueError: If any block's filepath doesn't match the target filepath
    """
    for b in edit_blocks:
        if (b.filepath != filepath): 
            raise ValueError(f"Block {b.filepath} does not match filepath {filepath}")
        
    # Read the original file content
    with open(filepath, 'r') as file:
        lines = file.readlines()
    
    # Sort the blocks by start line
    edit_blocks.sort(key=lambda x: x.start_line)
    
    # Track the line offset caused by previous edits
    line_offset = 0
    
    # Apply each edit block
    for block in edit_blocks:
        # Calculate the actual line numbers in the current file state
        current_start = block.start_line + line_offset
        current_end = current_start + block.len_lines_of_original_block - 1
        
        # Replace the lines in the file with the edited content if the lines
        lines = lines[:current_start] + [l.content for l in block.lines] + lines[current_end:]
        
        # Update the line offset for subsequent blocks
        line_offset += block.len_lines - block.len_lines_of_original_block
    
    # Write the modified content back to the file
    with open(filepath, 'w') as file:
        file.writelines(lines)